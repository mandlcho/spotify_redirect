<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Spotify Now Playing</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Space+Grotesk:wght@400;600;700&display=swap" rel="stylesheet">
  <style>
    :root {
      --bg: #0b1222;
      --card: #0f172a;
      --text: #e2e8f0;
      --muted: #94a3b8;
      --accent: #22c55e;
      --border: #1f2937;
      --shadow: 0 18px 80px rgba(0, 0, 0, 0.45);
      --mono: "SFMono-Regular", ui-monospace, Menlo, Consolas, "Liberation Mono", monospace;
      font-family: 'Space Grotesk', 'Segoe UI', system-ui, sans-serif;
    }
    * { box-sizing: border-box; }
    body {
      margin: 0;
      min-height: 100vh;
      background: radial-gradient(circle at 15% 20%, rgba(34,197,94,0.2), transparent 30%), var(--bg);
      color: var(--text);
      display: flex;
      justify-content: center;
      padding: 32px 18px 60px;
    }
    main { width: min(900px, 100%); display: flex; flex-direction: column; gap: 16px; }
    .card {
      background: var(--card);
      border: 1px solid var(--border);
      border-radius: 16px;
      padding: 18px 20px;
      box-shadow: var(--shadow);
    }
    h1 { margin: 0 0 6px; letter-spacing: -0.02em; }
    p { margin: 0; color: var(--muted); line-height: 1.5; }
    label { display: block; margin: 12px 0 6px; font-weight: 600; }
    input[type="text"] {
      width: 100%;
      padding: 12px 14px;
      border-radius: 12px;
      border: 1px solid var(--border);
      background: #0b1020;
      color: var(--text);
      font-family: var(--mono);
    }
    button {
      border: none;
      background: var(--accent);
      color: #0b1222;
      padding: 12px 16px;
      border-radius: 12px;
      font-weight: 700;
      cursor: pointer;
      width: 100%;
      margin-top: 10px;
      transition: transform 120ms ease, box-shadow 120ms ease;
      box-shadow: 0 12px 30px rgba(34, 197, 94, 0.25);
    }
    button.secondary { background: #111827; color: var(--text); border: 1px solid var(--border); box-shadow: none; }
    button:active { transform: translateY(1px); }
    .row { display: flex; justify-content: space-between; gap: 10px; padding: 12px 14px; border-radius: 12px; background: #0b1020; border: 1px solid var(--border); }
    .row .label { color: var(--muted); }
    .row .value { font-family: var(--mono); word-break: break-all; text-align: right; }
    .status { display: inline-flex; align-items: center; gap: 8px; padding: 8px 10px; border-radius: 12px; font-weight: 700; }
    .ok { background: rgba(34,197,94,0.15); color: #22c55e; }
    .warn { background: rgba(234,179,8,0.15); color: #eab308; }
    .error { background: rgba(248,113,113,0.15); color: #f87171; }
    .track {
      display: grid;
      grid-template-columns: 140px 1fr;
      gap: 14px;
      align-items: center;
    }
    .art {
      width: 140px;
      height: 140px;
      border-radius: 14px;
      background: #111827;
      display: flex;
      align-items: center;
      justify-content: center;
      color: #334155;
      overflow: hidden;
      box-shadow: 0 10px 30px rgba(0,0,0,0.35);
    }
    .art img { width: 100%; height: 100%; object-fit: cover; }
    .track h3 { margin: 0; }
    .track .artists { margin: 6px 0 0; color: var(--muted); }
    pre {
      background: #0b1020;
      border: 1px solid var(--border);
      border-radius: 12px;
      padding: 12px;
      overflow: auto;
      font-family: var(--mono);
      font-size: 0.92rem;
      max-height: 240px;
    }
    @media (max-width: 640px) {
      .track { grid-template-columns: 1fr; }
      .art { width: 100%; height: auto; aspect-ratio: 1 / 1; }
    }
  </style>
</head>
<body>
  <main>
    <section class="card">
      <h1>Spotify Now Playing</h1>
      <p>Simple client-side PKCE flow that shows your current track. Tokens stay in your browser. Register the redirect URI shown below in your Spotify app.</p>
    </section>

    <section class="card">
      <div class="row">
        <div class="label">Redirect URI to register in Spotify</div>
        <div class="value" id="redirect-uri">—</div>
      </div>
      <button class="secondary" id="copy-redirect">Copy Redirect URI</button>

      <label for="client-id">Spotify Client ID</label>
      <input id="client-id" type="text" placeholder="Paste your client_id" autocomplete="off" spellcheck="false">
      <button id="save-client">Save Client ID</button>
      <button class="secondary" id="connect">Connect to Spotify</button>
      <button class="secondary" id="clear">Clear stored tokens</button>

      <div class="row" style="margin-top:12px;">
        <div class="label">Auth</div>
        <div class="value" id="auth-state"><span class="status warn">Not connected</span></div>
      </div>
    </section>

    <section class="card">
      <div class="track">
        <div class="art" id="art">No artwork</div>
        <div>
          <h3 id="title">Nothing playing</h3>
          <div class="artists" id="artists">—</div>
          <div style="margin-top:10px;" class="row">
            <div class="label">Polling</div>
            <div class="value" id="polling">Every 10s</div>
          </div>
          <div class="row">
            <div class="label">Album</div>
            <div class="value" id="album">—</div>
          </div>
          <div class="row">
            <div class="label">Year</div>
            <div class="value" id="year">—</div>
          </div>
          <div class="row">
            <div class="label">Track ID</div>
            <div class="value mono" id="track-id">—</div>
          </div>
        </div>
      </div>
      <pre id="raw">{}</pre>
    </section>
  </main>

  <script>
    const scopes = ['user-read-currently-playing', 'user-read-playback-state'];
    const redirectUri = window.location.origin + window.location.pathname;

    const storage = {
      client: 'np_client_id',
      access: 'np_access',
      refresh: 'np_refresh',
      expiry: 'np_expiry',
      verifier: 'np_verifier'
    };

    const clientInput = document.getElementById('client-id');
    const redirectEl = document.getElementById('redirect-uri');
    const copyRedirectBtn = document.getElementById('copy-redirect');
    const saveBtn = document.getElementById('save-client');
    const connectBtn = document.getElementById('connect');
    const clearBtn = document.getElementById('clear');
    const authState = document.getElementById('auth-state');
    const titleEl = document.getElementById('title');
    const artistsEl = document.getElementById('artists');
    const artEl = document.getElementById('art');
    const rawEl = document.getElementById('raw');
    const pollingEl = document.getElementById('polling');
    const albumEl = document.getElementById('album');
    const yearEl = document.getElementById('year');
    const trackIdEl = document.getElementById('track-id');

    function badge(text, cls) {
      return `<span class="status ${cls}">${text}</span>`;
    }

    function randomString(len = 64) {
      const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
      const array = new Uint32Array(len);
      crypto.getRandomValues(array);
      return Array.from(array).map((x) => chars[x % chars.length]).join('');
    }

    async function sha256(input) {
      const data = new TextEncoder().encode(input);
      return crypto.subtle.digest('SHA-256', data);
    }

    function b64url(buffer) {
      return btoa(String.fromCharCode(...new Uint8Array(buffer)))
        .replace(/\+/g, '-')
        .replace(/\//g, '_')
        .replace(/=+$/, '');
    }

    function renderAuth(text, cls = 'warn') {
      authState.innerHTML = badge(text, cls);
    }

    function storeTokens(data, includeRefresh = true) {
      if (data.access_token) localStorage.setItem(storage.access, data.access_token);
      if (includeRefresh && data.refresh_token) localStorage.setItem(storage.refresh, data.refresh_token);
      const expiry = Date.now() + ((data.expires_in || 3600) * 1000) - 60000;
      localStorage.setItem(storage.expiry, String(expiry));
    }

    async function startAuth() {
      const clientId = clientInput.value.trim();
      if (!clientId) return renderAuth('Missing client_id', 'error');
      localStorage.setItem(storage.client, clientId);
      const verifier = randomString(64);
      localStorage.setItem(storage.verifier, verifier);
      const challenge = b64url(await sha256(verifier));
      const url = new URL('https://accounts.spotify.com/authorize');
      url.searchParams.set('client_id', clientId);
      url.searchParams.set('response_type', 'code');
      url.searchParams.set('redirect_uri', redirectUri);
      url.searchParams.set('code_challenge_method', 'S256');
      url.searchParams.set('code_challenge', challenge);
      url.searchParams.set('scope', scopes.join(' '));
      url.searchParams.set('state', randomString(12));
      window.location.href = url.toString();
    }

    async function exchangeCode(code) {
      const clientId = localStorage.getItem(storage.client);
      const verifier = localStorage.getItem(storage.verifier);
      const body = new URLSearchParams({
        client_id: clientId,
        grant_type: 'authorization_code',
        code,
        redirect_uri: redirectUri,
        code_verifier: verifier
      });
      const resp = await fetch('https://accounts.spotify.com/api/token', {
        method: 'POST',
        headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
        body
      });
      if (!resp.ok) throw new Error(`Token exchange failed (${resp.status})`);
      const data = await resp.json();
      storeTokens(data);
      renderAuth('Connected', 'ok');
    }

    async function refreshAccess() {
      const refresh = localStorage.getItem(storage.refresh);
      const clientId = localStorage.getItem(storage.client);
      if (!refresh || !clientId) throw new Error('No refresh token');
      const body = new URLSearchParams({
        grant_type: 'refresh_token',
        refresh_token: refresh,
        client_id: clientId
      });
      const resp = await fetch('https://accounts.spotify.com/api/token', {
        method: 'POST',
        headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
        body
      });
      if (!resp.ok) throw new Error(`Refresh failed (${resp.status})`);
      const data = await resp.json();
      storeTokens(data, false);
      renderAuth('Connected', 'ok');
    }

    async function ensureAccessToken() {
      const access = localStorage.getItem(storage.access);
      const expiry = Number(localStorage.getItem(storage.expiry));
      if (access && expiry && Date.now() < expiry) return access;
      await refreshAccess();
      return localStorage.getItem(storage.access);
    }

    function clearTokens() {
      Object.values(storage).forEach((k) => localStorage.removeItem(k));
      renderAuth('Tokens cleared', 'warn');
      titleEl.textContent = 'Nothing playing';
      artistsEl.textContent = '—';
      artEl.textContent = 'No artwork';
      albumEl.textContent = '—';
      yearEl.textContent = '—';
      trackIdEl.textContent = '—';
      rawEl.textContent = '{}';
    }

    async function fetchNowPlaying() {
      try {
        const token = await ensureAccessToken();
        if (!token) return;
        const resp = await fetch('https://api.spotify.com/v1/me/player/currently-playing', {
          headers: { Authorization: `Bearer ${token}` }
        });
        if (resp.status === 204) {
          titleEl.textContent = 'Nothing playing';
          artistsEl.textContent = '—';
          artEl.textContent = 'No artwork';
          rawEl.textContent = '{}';
          return;
        }
        if (resp.status === 401) {
          await refreshAccess();
          return;
        }
        if (!resp.ok) throw new Error(`Now playing failed (${resp.status})`);
        const data = await resp.json();
        rawEl.textContent = JSON.stringify(data, null, 2);
        if (data?.item) {
          titleEl.textContent = data.item.name || 'Unknown track';
          artistsEl.textContent = (data.item.artists || []).map((a) => a.name).join(', ') || 'Unknown artist';
          albumEl.textContent = data.item.album?.name || 'Unknown album';
          yearEl.textContent = (data.item.album?.release_date || '—').slice(0, 4) || '—';
          trackIdEl.textContent = data.item.id || '—';
          const img = data.item.album?.images?.[0]?.url;
          if (img) artEl.innerHTML = `<img src="${img}" alt="Album art">`;
          else artEl.textContent = 'No artwork';
        } else {
          titleEl.textContent = 'Nothing playing';
          artistsEl.textContent = '—';
          artEl.textContent = 'No artwork';
          albumEl.textContent = '—';
          yearEl.textContent = '—';
          trackIdEl.textContent = '—';
        }
      } catch (err) {
        renderAuth(err.message || 'Error', 'error');
      }
    }

    function handleRedirect() {
      const params = new URLSearchParams(window.location.search);
      const code = params.get('code');
      if (code) {
        exchangeCode(code)
          .then(() => {
            params.delete('code');
            params.delete('state');
            const next = `${window.location.origin}${window.location.pathname}${params.toString() ? '?' + params.toString() : ''}`;
            window.history.replaceState({}, document.title, next);
            fetchNowPlaying();
          })
          .catch((err) => renderAuth(err.message || 'Exchange failed', 'error'));
      }
    }

    function copyRedirect() {
      navigator.clipboard?.writeText(redirectUri)
        .then(() => copyRedirectBtn.textContent = 'Copied!')
        .catch(() => copyRedirectBtn.textContent = 'Copy failed');
      setTimeout(() => copyRedirectBtn.textContent = 'Copy Redirect URI', 1200);
    }

    function init() {
      redirectEl.textContent = redirectUri;
      pollingEl.textContent = 'Every 10s';
      const storedClient = localStorage.getItem(storage.client);
      if (storedClient) clientInput.value = storedClient;
      if (localStorage.getItem(storage.access)) renderAuth('Connected', 'ok');
      handleRedirect();
      fetchNowPlaying();
      setInterval(fetchNowPlaying, 10000);
    }

    saveBtn.addEventListener('click', () => {
      const cid = clientInput.value.trim();
      if (!cid) return;
      localStorage.setItem(storage.client, cid);
      renderAuth('Client ID saved', 'ok');
    });
    connectBtn.addEventListener('click', startAuth);
    clearBtn.addEventListener('click', clearTokens);
    copyRedirectBtn.addEventListener('click', copyRedirect);
    init();
  </script>
</body>
</html>
